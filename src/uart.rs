use crate::kmem::UART_BASE;
use crate::mmio::MMIORegister;
use crate::plic;
use crate::trap::UART_IRQ;
use crate::tty;
use crate::util::CircularBuffer;

/// UART routines and driver
/// Reference: http://byterunner.com/16550.html
use core::fmt::Error;
use core::fmt::Write;

#[macro_export]
macro_rules! print {
    ($($args:tt)*) => {{
        use core::fmt::Write;
        write!(crate::uart::Uart{}, $($args)*).unwrap();
    }};
}
#[macro_export]
macro_rules! println {
    ($($args:tt)*) => {{
        use core::fmt::Write;
        writeln!(crate::uart::Uart{}, $($args)*).unwrap();
    }};
}

const BAUD_RATE: usize = 2_400;

// UART registers
const RHR: UartRegister = UartRegister::read_only(0); // receive holding register (for input bytes)
const THR: UartRegister = UartRegister::write_only(0); // transmit holding register (for output bytes)
const DLL: UartRegister = UartRegister::write_only(0); // divisor latch LSB
const IER: UartRegister = UartRegister::write_only(1); // interrupt enable register
const DLM: UartRegister = UartRegister::write_only(1); // divisor latch MSB
const IER_RX_ENABLE: u8 = 1 << 0;
const IER_TX_ENABLE: u8 = 1 << 1;
const FCR: UartRegister = UartRegister::write_only(2); // FIFO control register
const FCR_FIFO_ENABLE: u8 = 1 << 0;
const FCR_FIFO_RESET: u8 = 0b11 << 1; // clear the content of the two FIFOs
const LCR: UartRegister = UartRegister::write_only(3); // line control register
const LCR_EIGHT_BITS: u8 = 0b11 << 0;
const LCR_BAUD_LATCH: u8 = 1 << 7; // special mode to set baud rate (DLAB)
const LSR: UartRegister = UartRegister::read_only(5); // line status register
const LSR_RX_READY: u8 = 1 << 0; // input is waiting to be read from RHR
const LSR_TX_IDLE: u8 = 1 << 5; // THR can accept another character to send

// UART transmit queue
static mut TX_QUEUE: CircularBuffer<u8, 32> = CircularBuffer::new();

pub fn handle_intr() {
    unsafe {
        // receive as many bytes as possible
        while LSR.read() & LSR_RX_READY != 0 {
            let byte: u8 = RHR.read();
            tty::handle_byte(byte);
        }
        // transmit as many bytes as possible
        try_flush();
    }
}

fn try_flush() {
    unsafe {
        while (LSR.read() & LSR_TX_IDLE) != 0 {
            match TX_QUEUE.read() {
                None => break,
                Some(byte) => THR.write(byte),
            }
        }
    }
}

pub struct Uart {}

impl Write for Uart {
    fn write_str(&mut self, out: &str) -> Result<(), Error> {
        for byte in out.bytes() {
            put(byte);
        }
        Ok(())
    }
}

pub fn get() -> Option<u8> {
    unsafe {
        if LSR.read() & LSR_RX_READY == 0 {
            // The DR bit is 0, meaning no data
            None
        } else {
            // The DR bit is 1, meaning data!
            Some(RHR.read())
        }
    }
}

pub fn put(byte: u8) {
    unsafe {
        while TX_QUEUE.write(byte) == None {
            try_flush();
        }
    }
}

/// Configure MMIO registers to enable UART communication and interrupts, though
/// QEMU's virtual UART device doesn't necessarily need to be properly set up
pub fn init() {
    unsafe {
        // Disable interrupts
        IER.write(0x00);

        // Calculate divisor = ceil(clock frequency / (16 * baud rate))
        // The device tree dump generated by `./qemu-ryos.sh -d` shows that the
        // 16550 UART device has a clock frequency of 3,686,400 Hz
        const CLOCK_HZ: usize = 3_686_400;
        const BAUD_OUT: usize = 16 * BAUD_RATE;
        const DIVISOR: usize = CLOCK_HZ.div_ceil(BAUD_OUT);
        if DIVISOR > 0xFFFF || CLOCK_HZ < BAUD_OUT {
            panic!("Invalid UART baud rate");
        }

        let divisor_lsb: u8 = (DIVISOR & 0xff).try_into().unwrap();
        let divisor_msb: u8 = (DIVISOR >> 8).try_into().unwrap();

        // Prepare to send divisor
        LCR.write(LCR_BAUD_LATCH);

        // Write divisor to DLL and DLM
        DLL.write(divisor_lsb);
        DLM.write(divisor_msb);

        // release baud latch and set word length to 8 bits, no parity
        LCR.write(LCR_EIGHT_BITS);

        // Clear and enable the FIFOs
        FCR.write(FCR_FIFO_RESET | FCR_FIFO_ENABLE);

        // Enable transmitter empty and receiver ready interrupts
        IER.write(IER_TX_ENABLE | IER_RX_ENABLE);

        plic::set_priority(UART_IRQ, 1);
        plic::enable(plic::PlicPrivilege::Supervisor, UART_IRQ);
        plic::set_threshold(plic::PlicPrivilege::Supervisor, 0);
    }
}

type UartRegister = MMIORegister<UART_BASE, u8>;
